// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc295.Grizzlynator2017.subsystems;

import org.usfirst.frc295.Grizzlynator2017.Drive.DriveSignal;
import org.usfirst.frc295.Grizzlynator2017.commands.CmdDriveWithJoystick;

import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * Troubleshooting: 1. OPERATING THE JOYSTICK TO GO STRAIGHT SPINS THE ROBOT
 * Invert the "setInvertedMotor" statements for one side
 *
 * 2. OPERATING THE JOYSTICK TO TURN RIGHT TURNS THE ROBOT LEFT Invert the
 * "setInvertedMotor" statements for all motors
 */
public abstract class SysDriveTrain extends Subsystem
{

	protected RobotDrive _robotDrive;

	// SENSORS
	protected Encoder _encoDriveRight;
	protected Encoder _encoDriveLeft;


	// THE ROBOT DRIVETRAIN'S VARIOUS STATES
	protected enum DriveControlState
	{
		OPEN_LOOP, BASE_LOCKED, VELOCITY_SETPOINT, VELOCITY_HEADING_CONTROL, PATH_FOLLOWING_CONTROL
	}

	protected DriveControlState _stateDriveControl = DriveControlState.OPEN_LOOP;


	public SysDriveTrain()
	{
		super();
	}


	@Override
	public void initDefaultCommand()
	{
		// Set the default command for a subsystem here.
		// DEFAULT FOR THIS SUBSYSTEM IS TO DRIVE WITH JOYSTICK
		setDefaultCommand(new CmdDriveWithJoystick());
	}


	public synchronized void setOpenLoop(DriveSignal signal)
	{
		if (_stateDriveControl != DriveControlState.OPEN_LOOP)
		{
			// _escLeftFront.changeControlMode(CANTalon.TalonControlMode.PercentVbus);
			// _escRightFront.changeControlMode(CANTalon.TalonControlMode.PercentVbus);
			_stateDriveControl = DriveControlState.OPEN_LOOP;
		}

		_robotDrive.tankDrive(signal.leftMotor, signal.rightMotor);
	}


	public synchronized void stop()
	{
		_robotDrive.setLeftRightMotorOutputs(0, 0);
	}


	public synchronized void arcadeDrive(double move, double rotation)
	{
		_robotDrive.arcadeDrive(move, rotation);
	}


	/**
	 * Reset the robots sensors to the zero states.
	 */
	public void reset()
	{
		// _gyro.reset();
		_encoDriveRight.reset();
		_encoDriveLeft.reset();
	}


	/**
	 * @return The robots heading in degrees.
	 */
	public double getHeading()
	{
		// return gyro.getAngle();
		return (0);
	}


	/**
	 * @return The distance driven (average of left and right encoders).
	 */
	public double getDistance()
	{
		return Math.abs((_encoDriveRight.getDistance() + _encoDriveLeft.getDistance()) / 2);
	}


	/**
	 * @return The distance to the obstacle detected by the rangefinder.
	 */
	public double getDistanceToObstacle()
	{
		// Really meters in simulation since it's a rangefinder...
		// return rangefinder.getAverageVoltage();
		return (0);
	}


	/**
	 * The log method puts interesting information to the SmartDashboard.
	 */
	public void logToSmartDashboard()
	{
		// SmartDashboard.putData("vibrate", new CmdHapticFeedback());
		SmartDashboard.putNumber("Left Distance", _encoDriveLeft.getDistance());
		SmartDashboard.putNumber("Right Distance", _encoDriveRight.getDistance());
		SmartDashboard.putNumber("Left Speed", _encoDriveLeft.getRate());
		SmartDashboard.putNumber("Right Speed", _encoDriveRight.getRate());
	}
}
